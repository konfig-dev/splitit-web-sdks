/* tslint:disable */
/* eslint-disable */
/**
 * splitit-web-api-v3
 * Splitit\'s Web API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { FailedResponse } from '../models';
// @ts-ignore
import { IdentifierContract } from '../models';
// @ts-ignore
import { InstallmentPlanCancelResponse } from '../models';
// @ts-ignore
import { InstallmentPlanRefundRequest } from '../models';
// @ts-ignore
import { InstallmentPlanRefundResponse } from '../models';
// @ts-ignore
import { InstallmentPlanUpdateRequestByIdentifier } from '../models';
// @ts-ignore
import { InstallmentPlanUpdateResponse } from '../models';
// @ts-ignore
import { RefundStrategy } from '../models';
// @ts-ignore
import { ShippingStatus } from '../models';
// @ts-ignore
import { ShippingStatus2 } from '../models';
// @ts-ignore
import { UpdateOrderRequest } from '../models';
import { paginate } from "../pagination/paginate";
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * MaintainPlansApi - axios parameter creator
 * @export
 */
export const MaintainPlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The Cancel operation allows you to cancel an existing installment plan.
         * @summary Cancel a Plan
         * @param {string} installmentPlanNumber 
         * @param {string} xSplititIdempotencyKey 
         * @param {string} xSplititTouchPoint TouchPoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (installmentPlanNumber: string, xSplititIdempotencyKey: string, xSplititTouchPoint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'installmentPlanNumber' is not null or undefined
            assertParamExists('cancel', 'installmentPlanNumber', installmentPlanNumber)
            // verify required parameter 'xSplititIdempotencyKey' is not null or undefined
            assertParamExists('cancel', 'xSplititIdempotencyKey', xSplititIdempotencyKey)
            // verify required parameter 'xSplititTouchPoint' is not null or undefined
            assertParamExists('cancel', 'xSplititTouchPoint', xSplititTouchPoint)
            const localVarPath = `/api/installmentplans/{installmentPlanNumber}/cancel`
                .replace(`{${"installmentPlanNumber"}}`, encodeURIComponent(String(installmentPlanNumber !== undefined ? installmentPlanNumber : `-installmentPlanNumber-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["api.v3"], configuration)
            if (xSplititIdempotencyKey != null) {
                localVarHeaderParameter['X-Splitit-IdempotencyKey'] = String(xSplititIdempotencyKey);
            }

            if (xSplititTouchPoint != null) {
                localVarHeaderParameter['X-Splitit-TouchPoint'] = String(xSplititTouchPoint);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund part or all of an installment Plan.  Strategies There are several refund strategies you can choose when refunding a plan (note that the default is FutureInstallmentsFirst):  - FutureInstallmentsFirst: At first customer isn’t refunded any installment money that they have already paid. Instead their refund lessens the amount of future installments they will be debited for, beginning with the next installment that is due. However, if their refund exceeds the amount of money they have left to pay (all installments), only then is the refund taken out of the installment money they have already paid - FutureInstallmentsLast: Customer is refunded beginning with the installment money they have already paid. If their refund amount exceeds the amount they have already paid, their amount of future installments due gets decreased, beginning with the next installment due and then proceeding to the later ones - FutureInstallmentsNotAllowed: Customer is only refunded from installment money that they have already paid, not from any future installments that they have due - ReduceFromLastInstallment: This is the same as FutureInstallmentsFirst, except that the refund is credited starting with the last installment first (e.g., number 6 of 6, as opposed to number 2 of 6). 
         * @summary Refund a Plan
         * @param {string} installmentPlanNumber 
         * @param {string} xSplititIdempotencyKey 
         * @param {string} xSplititTouchPoint TouchPoint
         * @param {InstallmentPlanRefundRequest} installmentPlanRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refund: async (installmentPlanNumber: string, xSplititIdempotencyKey: string, xSplititTouchPoint: string, installmentPlanRefundRequest: InstallmentPlanRefundRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'installmentPlanNumber' is not null or undefined
            assertParamExists('refund', 'installmentPlanNumber', installmentPlanNumber)
            // verify required parameter 'xSplititIdempotencyKey' is not null or undefined
            assertParamExists('refund', 'xSplititIdempotencyKey', xSplititIdempotencyKey)
            // verify required parameter 'xSplititTouchPoint' is not null or undefined
            assertParamExists('refund', 'xSplititTouchPoint', xSplititTouchPoint)
            // verify required parameter 'installmentPlanRefundRequest' is not null or undefined
            assertParamExists('refund', 'installmentPlanRefundRequest', installmentPlanRefundRequest)
            const localVarPath = `/api/installmentplans/{installmentPlanNumber}/refund`
                .replace(`{${"installmentPlanNumber"}}`, encodeURIComponent(String(installmentPlanNumber !== undefined ? installmentPlanNumber : `-installmentPlanNumber-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["api.v3"], configuration)
            if (xSplititIdempotencyKey != null) {
                localVarHeaderParameter['X-Splitit-IdempotencyKey'] = String(xSplititIdempotencyKey);
            }

            if (xSplititTouchPoint != null) {
                localVarHeaderParameter['X-Splitit-TouchPoint'] = String(xSplititTouchPoint);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: installmentPlanRefundRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(installmentPlanRefundRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Locate a plan by installment number then carry out post-authorization activities related to the plan, such as updating the order number, updating the tracking number, or updating shipping status. You can also use this endpoint to capture the first installment from a plan that has only been authorized but not yet captured.
         * @summary Update Plan by Number
         * @param {string} installmentPlanNumber 
         * @param {string} xSplititIdempotencyKey 
         * @param {string} xSplititTouchPoint TouchPoint
         * @param {UpdateOrderRequest} updateOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder: async (installmentPlanNumber: string, xSplititIdempotencyKey: string, xSplititTouchPoint: string, updateOrderRequest: UpdateOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'installmentPlanNumber' is not null or undefined
            assertParamExists('updateOrder', 'installmentPlanNumber', installmentPlanNumber)
            // verify required parameter 'xSplititIdempotencyKey' is not null or undefined
            assertParamExists('updateOrder', 'xSplititIdempotencyKey', xSplititIdempotencyKey)
            // verify required parameter 'xSplititTouchPoint' is not null or undefined
            assertParamExists('updateOrder', 'xSplititTouchPoint', xSplititTouchPoint)
            // verify required parameter 'updateOrderRequest' is not null or undefined
            assertParamExists('updateOrder', 'updateOrderRequest', updateOrderRequest)
            const localVarPath = `/api/installmentplans/{installmentPlanNumber}/updateorder`
                .replace(`{${"installmentPlanNumber"}}`, encodeURIComponent(String(installmentPlanNumber !== undefined ? installmentPlanNumber : `-installmentPlanNumber-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["api.v3"], configuration)
            if (xSplititIdempotencyKey != null) {
                localVarHeaderParameter['X-Splitit-IdempotencyKey'] = String(xSplititIdempotencyKey);
            }

            if (xSplititTouchPoint != null) {
                localVarHeaderParameter['X-Splitit-TouchPoint'] = String(xSplititTouchPoint);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: updateOrderRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Locate a plan by RefOrderNumber or ExtendedParams then carry out post-authorization activities related to the plan, such as updating the order number, updating the tracking number, or updating shipping status. You can also use this endpoint to capture the first installment from a plan that has only been authorized but not yet captured. Note that RefOrderNumber or ExtendedParams were optionally specified by you upon plan creation.
         * @summary Update Plan By Alternate Field
         * @param {string} xSplititIdempotencyKey 
         * @param {string} xSplititTouchPoint TouchPoint
         * @param {InstallmentPlanUpdateRequestByIdentifier} installmentPlanUpdateRequestByIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder2: async (xSplititIdempotencyKey: string, xSplititTouchPoint: string, installmentPlanUpdateRequestByIdentifier: InstallmentPlanUpdateRequestByIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xSplititIdempotencyKey' is not null or undefined
            assertParamExists('updateOrder2', 'xSplititIdempotencyKey', xSplititIdempotencyKey)
            // verify required parameter 'xSplititTouchPoint' is not null or undefined
            assertParamExists('updateOrder2', 'xSplititTouchPoint', xSplititTouchPoint)
            // verify required parameter 'installmentPlanUpdateRequestByIdentifier' is not null or undefined
            assertParamExists('updateOrder2', 'installmentPlanUpdateRequestByIdentifier', installmentPlanUpdateRequestByIdentifier)
            const localVarPath = `/api/installmentplans/updateorder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["api.v3"], configuration)
            if (xSplititIdempotencyKey != null) {
                localVarHeaderParameter['X-Splitit-IdempotencyKey'] = String(xSplititIdempotencyKey);
            }

            if (xSplititTouchPoint != null) {
                localVarHeaderParameter['X-Splitit-TouchPoint'] = String(xSplititTouchPoint);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: installmentPlanUpdateRequestByIdentifier,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(installmentPlanUpdateRequestByIdentifier, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaintainPlansApi - functional programming interface
 * @export
 */
export const MaintainPlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaintainPlansApiAxiosParamCreator(configuration)
    return {
        /**
         * The Cancel operation allows you to cancel an existing installment plan.
         * @summary Cancel a Plan
         * @param {MaintainPlansApiCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(requestParameters: MaintainPlansApiCancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstallmentPlanCancelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(requestParameters.installmentPlanNumber, requestParameters.xSplititIdempotencyKey, requestParameters.xSplititTouchPoint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refund part or all of an installment Plan.  Strategies There are several refund strategies you can choose when refunding a plan (note that the default is FutureInstallmentsFirst):  - FutureInstallmentsFirst: At first customer isn’t refunded any installment money that they have already paid. Instead their refund lessens the amount of future installments they will be debited for, beginning with the next installment that is due. However, if their refund exceeds the amount of money they have left to pay (all installments), only then is the refund taken out of the installment money they have already paid - FutureInstallmentsLast: Customer is refunded beginning with the installment money they have already paid. If their refund amount exceeds the amount they have already paid, their amount of future installments due gets decreased, beginning with the next installment due and then proceeding to the later ones - FutureInstallmentsNotAllowed: Customer is only refunded from installment money that they have already paid, not from any future installments that they have due - ReduceFromLastInstallment: This is the same as FutureInstallmentsFirst, except that the refund is credited starting with the last installment first (e.g., number 6 of 6, as opposed to number 2 of 6). 
         * @summary Refund a Plan
         * @param {MaintainPlansApiRefundRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refund(requestParameters: MaintainPlansApiRefundRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstallmentPlanRefundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refund(requestParameters.installmentPlanNumber, requestParameters.xSplititIdempotencyKey, requestParameters.xSplititTouchPoint, requestParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Locate a plan by installment number then carry out post-authorization activities related to the plan, such as updating the order number, updating the tracking number, or updating shipping status. You can also use this endpoint to capture the first installment from a plan that has only been authorized but not yet captured.
         * @summary Update Plan by Number
         * @param {MaintainPlansApiUpdateOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrder(requestParameters: MaintainPlansApiUpdateOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstallmentPlanUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder(requestParameters.installmentPlanNumber, requestParameters.xSplititIdempotencyKey, requestParameters.xSplititTouchPoint, requestParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Locate a plan by RefOrderNumber or ExtendedParams then carry out post-authorization activities related to the plan, such as updating the order number, updating the tracking number, or updating shipping status. You can also use this endpoint to capture the first installment from a plan that has only been authorized but not yet captured. Note that RefOrderNumber or ExtendedParams were optionally specified by you upon plan creation.
         * @summary Update Plan By Alternate Field
         * @param {MaintainPlansApiUpdateOrder2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrder2(requestParameters: MaintainPlansApiUpdateOrder2Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstallmentPlanUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder2(requestParameters.xSplititIdempotencyKey, requestParameters.xSplititTouchPoint, requestParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MaintainPlansApi - factory interface
 * @export
 */
export const MaintainPlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaintainPlansApiFp(configuration)
    return {
        /**
         * The Cancel operation allows you to cancel an existing installment plan.
         * @summary Cancel a Plan
         * @param {MaintainPlansApiCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(requestParameters: MaintainPlansApiCancelRequest, options?: AxiosRequestConfig): AxiosPromise<InstallmentPlanCancelResponse> {
            return localVarFp.cancel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund part or all of an installment Plan.  Strategies There are several refund strategies you can choose when refunding a plan (note that the default is FutureInstallmentsFirst):  - FutureInstallmentsFirst: At first customer isn’t refunded any installment money that they have already paid. Instead their refund lessens the amount of future installments they will be debited for, beginning with the next installment that is due. However, if their refund exceeds the amount of money they have left to pay (all installments), only then is the refund taken out of the installment money they have already paid - FutureInstallmentsLast: Customer is refunded beginning with the installment money they have already paid. If their refund amount exceeds the amount they have already paid, their amount of future installments due gets decreased, beginning with the next installment due and then proceeding to the later ones - FutureInstallmentsNotAllowed: Customer is only refunded from installment money that they have already paid, not from any future installments that they have due - ReduceFromLastInstallment: This is the same as FutureInstallmentsFirst, except that the refund is credited starting with the last installment first (e.g., number 6 of 6, as opposed to number 2 of 6). 
         * @summary Refund a Plan
         * @param {MaintainPlansApiRefundRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refund(requestParameters: MaintainPlansApiRefundRequest, options?: AxiosRequestConfig): AxiosPromise<InstallmentPlanRefundResponse> {
            return localVarFp.refund(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Locate a plan by installment number then carry out post-authorization activities related to the plan, such as updating the order number, updating the tracking number, or updating shipping status. You can also use this endpoint to capture the first installment from a plan that has only been authorized but not yet captured.
         * @summary Update Plan by Number
         * @param {MaintainPlansApiUpdateOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(requestParameters: MaintainPlansApiUpdateOrderRequest, options?: AxiosRequestConfig): AxiosPromise<InstallmentPlanUpdateResponse> {
            return localVarFp.updateOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Locate a plan by RefOrderNumber or ExtendedParams then carry out post-authorization activities related to the plan, such as updating the order number, updating the tracking number, or updating shipping status. You can also use this endpoint to capture the first installment from a plan that has only been authorized but not yet captured. Note that RefOrderNumber or ExtendedParams were optionally specified by you upon plan creation.
         * @summary Update Plan By Alternate Field
         * @param {MaintainPlansApiUpdateOrder2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder2(requestParameters: MaintainPlansApiUpdateOrder2Request, options?: AxiosRequestConfig): AxiosPromise<InstallmentPlanUpdateResponse> {
            return localVarFp.updateOrder2(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in MaintainPlansApi.
 * @export
 * @interface MaintainPlansApiCancelRequest
 */
export type MaintainPlansApiCancelRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof MaintainPlansApiCancel
    */
    readonly installmentPlanNumber: string
    
    /**
    * 
    * @type {string}
    * @memberof MaintainPlansApiCancel
    */
    readonly xSplititIdempotencyKey: string
    
    /**
    * TouchPoint
    * @type {string}
    * @memberof MaintainPlansApiCancel
    */
    readonly xSplititTouchPoint: string
    
}

/**
 * Request parameters for refund operation in MaintainPlansApi.
 * @export
 * @interface MaintainPlansApiRefundRequest
 */
export type MaintainPlansApiRefundRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof MaintainPlansApiRefund
    */
    readonly installmentPlanNumber: string
    
    /**
    * 
    * @type {string}
    * @memberof MaintainPlansApiRefund
    */
    readonly xSplititIdempotencyKey: string
    
    /**
    * TouchPoint
    * @type {string}
    * @memberof MaintainPlansApiRefund
    */
    readonly xSplititTouchPoint: string
    
} & InstallmentPlanRefundRequest

/**
 * Request parameters for updateOrder operation in MaintainPlansApi.
 * @export
 * @interface MaintainPlansApiUpdateOrderRequest
 */
export type MaintainPlansApiUpdateOrderRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof MaintainPlansApiUpdateOrder
    */
    readonly installmentPlanNumber: string
    
    /**
    * 
    * @type {string}
    * @memberof MaintainPlansApiUpdateOrder
    */
    readonly xSplititIdempotencyKey: string
    
    /**
    * TouchPoint
    * @type {string}
    * @memberof MaintainPlansApiUpdateOrder
    */
    readonly xSplititTouchPoint: string
    
} & UpdateOrderRequest

/**
 * Request parameters for updateOrder2 operation in MaintainPlansApi.
 * @export
 * @interface MaintainPlansApiUpdateOrder2Request
 */
export type MaintainPlansApiUpdateOrder2Request = {
    
    /**
    * 
    * @type {string}
    * @memberof MaintainPlansApiUpdateOrder2
    */
    readonly xSplititIdempotencyKey: string
    
    /**
    * TouchPoint
    * @type {string}
    * @memberof MaintainPlansApiUpdateOrder2
    */
    readonly xSplititTouchPoint: string
    
} & InstallmentPlanUpdateRequestByIdentifier

/**
 * MaintainPlansApiGenerated - object-oriented interface
 * @export
 * @class MaintainPlansApiGenerated
 * @extends {BaseAPI}
 */
export class MaintainPlansApiGenerated extends BaseAPI {
    /**
     * The Cancel operation allows you to cancel an existing installment plan.
     * @summary Cancel a Plan
     * @param {MaintainPlansApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintainPlansApiGenerated
     */
    public cancel(requestParameters: MaintainPlansApiCancelRequest, options?: AxiosRequestConfig) {
        return MaintainPlansApiFp(this.configuration).cancel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund part or all of an installment Plan.  Strategies There are several refund strategies you can choose when refunding a plan (note that the default is FutureInstallmentsFirst):  - FutureInstallmentsFirst: At first customer isn’t refunded any installment money that they have already paid. Instead their refund lessens the amount of future installments they will be debited for, beginning with the next installment that is due. However, if their refund exceeds the amount of money they have left to pay (all installments), only then is the refund taken out of the installment money they have already paid - FutureInstallmentsLast: Customer is refunded beginning with the installment money they have already paid. If their refund amount exceeds the amount they have already paid, their amount of future installments due gets decreased, beginning with the next installment due and then proceeding to the later ones - FutureInstallmentsNotAllowed: Customer is only refunded from installment money that they have already paid, not from any future installments that they have due - ReduceFromLastInstallment: This is the same as FutureInstallmentsFirst, except that the refund is credited starting with the last installment first (e.g., number 6 of 6, as opposed to number 2 of 6). 
     * @summary Refund a Plan
     * @param {MaintainPlansApiRefundRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintainPlansApiGenerated
     */
    public refund(requestParameters: MaintainPlansApiRefundRequest, options?: AxiosRequestConfig) {
        return MaintainPlansApiFp(this.configuration).refund(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Locate a plan by installment number then carry out post-authorization activities related to the plan, such as updating the order number, updating the tracking number, or updating shipping status. You can also use this endpoint to capture the first installment from a plan that has only been authorized but not yet captured.
     * @summary Update Plan by Number
     * @param {MaintainPlansApiUpdateOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintainPlansApiGenerated
     */
    public updateOrder(requestParameters: MaintainPlansApiUpdateOrderRequest, options?: AxiosRequestConfig) {
        return MaintainPlansApiFp(this.configuration).updateOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Locate a plan by RefOrderNumber or ExtendedParams then carry out post-authorization activities related to the plan, such as updating the order number, updating the tracking number, or updating shipping status. You can also use this endpoint to capture the first installment from a plan that has only been authorized but not yet captured. Note that RefOrderNumber or ExtendedParams were optionally specified by you upon plan creation.
     * @summary Update Plan By Alternate Field
     * @param {MaintainPlansApiUpdateOrder2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintainPlansApiGenerated
     */
    public updateOrder2(requestParameters: MaintainPlansApiUpdateOrder2Request, options?: AxiosRequestConfig) {
        return MaintainPlansApiFp(this.configuration).updateOrder2(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
